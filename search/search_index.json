{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Getting Started Installation go get github.com/ahsayde/yapl/yapl Usage import ( \"fmt\" \"io/ioutil\" \"github.com/ahsayde/yapl/yapl\" ) func main () { input := map [ string ] interface {}{ \"method\" : \"GET\" , \"endpoint\" : \"/users\" } params := map [ string ] interface {}{ \"method\" : \"GET\" } raw , err := ioutil . ReadFile ( \"policy.yaml\" ) if err != nil { panic ( err ) } policy , err := yapl . Parse ( raw ) if err != nil { panic ( err ) } result , err := policy . Eval ( input , params ) if err != nil { panic ( err ) } fmt . Println ( result ) } Writing Policies See Policy Syntax documentation to learn how to write yapl policies.","title":"Getting Started"},{"location":"#getting-started","text":"","title":"Getting Started"},{"location":"#installation","text":"go get github.com/ahsayde/yapl/yapl","title":"Installation"},{"location":"#usage","text":"import ( \"fmt\" \"io/ioutil\" \"github.com/ahsayde/yapl/yapl\" ) func main () { input := map [ string ] interface {}{ \"method\" : \"GET\" , \"endpoint\" : \"/users\" } params := map [ string ] interface {}{ \"method\" : \"GET\" } raw , err := ioutil . ReadFile ( \"policy.yaml\" ) if err != nil { panic ( err ) } policy , err := yapl . Parse ( raw ) if err != nil { panic ( err ) } result , err := policy . Eval ( input , params ) if err != nil { panic ( err ) } fmt . Println ( result ) }","title":"Usage"},{"location":"#writing-policies","text":"See Policy Syntax documentation to learn how to write yapl policies.","title":"Writing Policies"},{"location":"syntax/","text":"Concepts Policy Structure Expression Expressions are used to programmatically generate dynamic values. An expression can be any combination of literal values, contexts , or functions . Expressions can be used anywhere in the policies and it uses Golang template syntax with delims ${ , } Examples Evaluate context ${ .Params.my_parameter } See Contexts for more information Evaluate context and functions ${ .Params.my_parameter | upper } See Functions for more information Evaluate string, context and functions directory: ${ index (split .Params.path \"/\") 0 } Condition Condition is the main component in yapl policy and it is re-used everywhere in the policy. Field Type Notes Description field string required The json path of the field to evaluate. expr string optional Expression to evaluate. If provided condition will compare its value instead of field 's value. operator string required condition's operator. Available operators are here . value any required value to compare field 's or expr 's' value with. Examples The following example checks if field metadata.namespace is equals default or not. field : metadata.namespace operator : equal value : default To check a field in arrays you can use [<index>] to access the array index or use [*] to evaluate all items in the array Check only first container field : spec.containers[0].name operator : hasPrefix value : container- Check all containers field : spec.containers[*].name operator : hasPrefix value : container- expr field can be used to do some changes to the value of the field before the condition evaluation. For example: field : metadata.namespace expr : ${ .Cond.Field.Value | upper } operator : equal value : DEFAUT Logical Condition Logical condition combine the result of multiple conditions to produce a single result. Logical operators and , or and not are used to define the relationship of conditions. Logical condition can has multiple levels. Examples and : - < condition > - < condition > or : - < condition > - < condition > not : < condition > and : - < condition > - < condition > - or : - < condition > - < condition > - not : < condition >","title":"Concepts"},{"location":"syntax/#concepts","text":"","title":"Concepts"},{"location":"syntax/#policy-structure","text":"","title":"Policy Structure"},{"location":"syntax/#expression","text":"Expressions are used to programmatically generate dynamic values. An expression can be any combination of literal values, contexts , or functions . Expressions can be used anywhere in the policies and it uses Golang template syntax with delims ${ , }","title":"Expression"},{"location":"syntax/#examples","text":"Evaluate context ${ .Params.my_parameter } See Contexts for more information Evaluate context and functions ${ .Params.my_parameter | upper } See Functions for more information Evaluate string, context and functions directory: ${ index (split .Params.path \"/\") 0 }","title":"Examples"},{"location":"syntax/#condition","text":"Condition is the main component in yapl policy and it is re-used everywhere in the policy. Field Type Notes Description field string required The json path of the field to evaluate. expr string optional Expression to evaluate. If provided condition will compare its value instead of field 's value. operator string required condition's operator. Available operators are here . value any required value to compare field 's or expr 's' value with.","title":"Condition"},{"location":"syntax/#examples_1","text":"The following example checks if field metadata.namespace is equals default or not. field : metadata.namespace operator : equal value : default To check a field in arrays you can use [<index>] to access the array index or use [*] to evaluate all items in the array Check only first container field : spec.containers[0].name operator : hasPrefix value : container- Check all containers field : spec.containers[*].name operator : hasPrefix value : container- expr field can be used to do some changes to the value of the field before the condition evaluation. For example: field : metadata.namespace expr : ${ .Cond.Field.Value | upper } operator : equal value : DEFAUT","title":"Examples"},{"location":"syntax/#logical-condition","text":"Logical condition combine the result of multiple conditions to produce a single result. Logical operators and , or and not are used to define the relationship of conditions. Logical condition can has multiple levels.","title":"Logical Condition"},{"location":"syntax/#examples_2","text":"and : - < condition > - < condition > or : - < condition > - < condition > not : < condition > and : - < condition > - < condition > - or : - < condition > - < condition > - not : < condition >","title":"Examples"},{"location":"syntax/contexts/","text":"Context Contexts are a way to access information about policy runtime Available Contexts .Input .Params .Env .Cond Input Input contex allow you to access the resource object using ${ .Input.< field json path > } expression. Example rules : - condition : field : metadata.name operator : hasPrefix value : app result : msg : resource name ${ .Input.metadata.name } must start with prefix 'app' Parameters You can access parameters passed during the evaluation of input using expression ${ .Params.<variable name> } . Example exclude : field : metadata.namespace operator : in value : ${ .Params.excluded_namespaces } Environment Variables You can access environment variable value by using expression ${ .Env.<variable name> } Example rules : - condition : field : request.body operator : maxLength value : ${ .Env.MAX_BODY_SIZE } result : request body must not exceed ${ .Env.MAX_BODY_SIZE } Current Condition Cond context allow you to access all the information of the current condition. This context is only availabe on field rules.result . Key Type Description Cond.Field.Value any The value of the field Cond.Field.Index integer The index of the field if field's parent is an array Cond.Field.Parent [field object] The parent of the field Cond.Operator string Condition's operator Cond.Value string Condition's value Examples rules : - condition : field : metadata.name operator : hasPrefix value : app result : msg : resource name must starts with ${ .Cond.Value } but found ${ .Cond.Field.Value } key : ${ .Field.Path } rules : - condition : field : spec.containers[*].image operator : hasPrefix value : my-registry result : msg : container ${ .Cond.Field.Parent.Value.name } uses invalid image registry","title":"Context"},{"location":"syntax/contexts/#context","text":"Contexts are a way to access information about policy runtime","title":"Context"},{"location":"syntax/contexts/#available-contexts","text":".Input .Params .Env .Cond","title":"Available Contexts"},{"location":"syntax/contexts/#input","text":"Input contex allow you to access the resource object using ${ .Input.< field json path > } expression.","title":"Input"},{"location":"syntax/contexts/#example","text":"rules : - condition : field : metadata.name operator : hasPrefix value : app result : msg : resource name ${ .Input.metadata.name } must start with prefix 'app'","title":"Example"},{"location":"syntax/contexts/#parameters","text":"You can access parameters passed during the evaluation of input using expression ${ .Params.<variable name> } .","title":"Parameters"},{"location":"syntax/contexts/#example_1","text":"exclude : field : metadata.namespace operator : in value : ${ .Params.excluded_namespaces }","title":"Example"},{"location":"syntax/contexts/#environment-variables","text":"You can access environment variable value by using expression ${ .Env.<variable name> }","title":"Environment Variables"},{"location":"syntax/contexts/#example_2","text":"rules : - condition : field : request.body operator : maxLength value : ${ .Env.MAX_BODY_SIZE } result : request body must not exceed ${ .Env.MAX_BODY_SIZE }","title":"Example"},{"location":"syntax/contexts/#current-condition","text":"Cond context allow you to access all the information of the current condition. This context is only availabe on field rules.result . Key Type Description Cond.Field.Value any The value of the field Cond.Field.Index integer The index of the field if field's parent is an array Cond.Field.Parent [field object] The parent of the field Cond.Operator string Condition's operator Cond.Value string Condition's value","title":"Current Condition"},{"location":"syntax/contexts/#examples","text":"rules : - condition : field : metadata.name operator : hasPrefix value : app result : msg : resource name must starts with ${ .Cond.Value } but found ${ .Cond.Field.Value } key : ${ .Field.Path } rules : - condition : field : spec.containers[*].image operator : hasPrefix value : my-registry result : msg : container ${ .Cond.Field.Parent.Value.name } uses invalid image registry","title":"Examples"},{"location":"syntax/functions/","text":"Functions Functions are used in expressions . They can take arguments and return values. Built-in Functions Here is the list of the builtin functions which can be used in expressions String split lower upper title join trim trimLeft trimRigh trimPrefix trimSuffix replace replaceAll Math round ceil abs floor max min Date & Time date now year month weekday day hour minute second Type Conversion bool Helpers ternary","title":"Functions"},{"location":"syntax/functions/#functions","text":"Functions are used in expressions . They can take arguments and return values.","title":"Functions"},{"location":"syntax/functions/#built-in-functions","text":"Here is the list of the builtin functions which can be used in expressions","title":"Built-in Functions"},{"location":"syntax/functions/#string","text":"split lower upper title join trim trimLeft trimRigh trimPrefix trimSuffix replace replaceAll","title":"String"},{"location":"syntax/functions/#math","text":"round ceil abs floor max min","title":"Math"},{"location":"syntax/functions/#date-time","text":"date now year month weekday day hour minute second","title":"Date &amp; Time"},{"location":"syntax/functions/#type-conversion","text":"bool","title":"Type Conversion"},{"location":"syntax/functions/#helpers","text":"ternary","title":"Helpers"},{"location":"syntax/operators/","text":"Operators Built-in Operators Here is the list of the availabe operators which can be used in conditions . Operator Alias Description Field Value Operator Value equal eq Checks field's value equal provided value any any hasPrefix Checks whether field's value begins with prefix string string hasSuffix Checks whether field's value ends with suffix string string regex Checks whether field's value matches the provided regex string string minValue min Checks whether field's value is greater than or equals provided value number number maxValue max Checks whether field's value is less than or equals the provided value number number in Checks whether field's value in the provided value any array contains Checks whether field's value contains the provided value array any length len Checks whether field's value length equals the provided value array integer minLength minlen Checks whether field's value has minimum length equals the provided value array integer maxLength maxlen Checks whether field's value has maximum length equals the provided value array integer","title":"Operators"},{"location":"syntax/operators/#operators","text":"","title":"Operators"},{"location":"syntax/operators/#built-in-operators","text":"Here is the list of the availabe operators which can be used in conditions . Operator Alias Description Field Value Operator Value equal eq Checks field's value equal provided value any any hasPrefix Checks whether field's value begins with prefix string string hasSuffix Checks whether field's value ends with suffix string string regex Checks whether field's value matches the provided regex string string minValue min Checks whether field's value is greater than or equals provided value number number maxValue max Checks whether field's value is less than or equals the provided value number number in Checks whether field's value in the provided value any array contains Checks whether field's value contains the provided value array any length len Checks whether field's value length equals the provided value array integer minLength minlen Checks whether field's value has minimum length equals the provided value array integer maxLength maxlen Checks whether field's value has maximum length equals the provided value array integer","title":"Built-in Operators"},{"location":"syntax/statments/","text":"Statements Match The match statement provides a way to filter resources which will be validated by the policy. It can be a condition or a logical condition . Examples match statement with single condition: match : field : kind operator : equal value : Deployment match statement with logical conditions: match : and : - field : kind operator : equal value : Deployment - field : metadata.namespace operator : equal value : default Exclude The exclude statement is used to exclude resources from being validated by the policy. It can be a condition or a logical conditions . Examples exclude statement with single condition: exclude : field : metadata.namespace operator : equal value : kube-system exclude statement with logical conditions: exclude : or : - field : kind operator : equal value : Secret - field : metadata.namespace operator : equal value : kube-system Globals New in v0.2.0 Globals allows provides a way to define global variables once and use it anywhere inside the policy. Examples globals : resourceId : ${ .Input.metadata.name }/${ .Input.metadata.namespace } match : expr : ${ .Globals.resourceId } operator : equal value : my-app/my-namespace Rules A yapl policy can contain one or more rules . Each rule consist of a condition and a result rules : - condition : field : metadata.name equal : hasPrefix value : app result : msg : resource name must starts with 'app' Conditional Rules to add a condition when a rule is evaluated you can use when field to define a condition when a rule can be evaluated rules : - when : < condition or logical condition > condition : < condition > result : < result >","title":"Statements"},{"location":"syntax/statments/#statements","text":"","title":"Statements"},{"location":"syntax/statments/#match","text":"The match statement provides a way to filter resources which will be validated by the policy. It can be a condition or a logical condition .","title":"Match"},{"location":"syntax/statments/#examples","text":"match statement with single condition: match : field : kind operator : equal value : Deployment match statement with logical conditions: match : and : - field : kind operator : equal value : Deployment - field : metadata.namespace operator : equal value : default","title":"Examples"},{"location":"syntax/statments/#exclude","text":"The exclude statement is used to exclude resources from being validated by the policy. It can be a condition or a logical conditions .","title":"Exclude"},{"location":"syntax/statments/#examples_1","text":"exclude statement with single condition: exclude : field : metadata.namespace operator : equal value : kube-system exclude statement with logical conditions: exclude : or : - field : kind operator : equal value : Secret - field : metadata.namespace operator : equal value : kube-system","title":"Examples"},{"location":"syntax/statments/#globals","text":"New in v0.2.0 Globals allows provides a way to define global variables once and use it anywhere inside the policy.","title":"Globals"},{"location":"syntax/statments/#examples_2","text":"globals : resourceId : ${ .Input.metadata.name }/${ .Input.metadata.namespace } match : expr : ${ .Globals.resourceId } operator : equal value : my-app/my-namespace","title":"Examples"},{"location":"syntax/statments/#rules","text":"A yapl policy can contain one or more rules . Each rule consist of a condition and a result rules : - condition : field : metadata.name equal : hasPrefix value : app result : msg : resource name must starts with 'app'","title":"Rules"},{"location":"syntax/statments/#conditional-rules","text":"to add a condition when a rule is evaluated you can use when field to define a condition when a rule can be evaluated rules : - when : < condition or logical condition > condition : < condition > result : < result >","title":"Conditional Rules"}]}